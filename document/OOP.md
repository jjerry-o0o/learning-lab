객체 지향 설계에서 불변 객체를 만드는 것은 중요하다.
- 멀티 쓰레드 환경에서 공유 되는 객체의 상태가 변경되어 문제가 발생할 상황을 방지해준다.
- 객체를 사용함에 있어 안정된, 예상 가능한 값을 보장하기 때문에, 부수적인 추가 작업(객체의 변경 상태 체크, 동기화 작업 등)을 하지 않아도 된다.
- 가비지 컬렉션의 성능 향상에 도움이 된다.
- 




### 가비지 컬렉션 
> 객체 지향적으로 설계하는 것이 중요한 이유에 대해 공부하다 보니 기존에 알고있던 것들(재사용성, 변경/이해하기 쉬운 코드) 외에   
> GC 의 성능을 위해서라는 부분도 있다는걸 알게 되었고, GC 가 동작하는 동안 서비스 관련 Thread가 동작을 멈추기 때문에 STW 가 발생한다는 것을 알게 됨.   
> 이하 GC 에 대해 공부하고 이해한 내용 정리...


- 자바 힙 영역에서 동적으로 할당된 메모리 중에 더 이상 사용하지않는 메모리를 제거해주는 프로세스
- GC 가 동작하는 동안 GC 관련 Thread 를 제외한 다른 Thread (서비스 관련 등) 는 동작을 멈추게 된다.
- 이처럼 JVM 이 멈추는 현상을 STW(Stop-The-World) 라고 하며, 이 시간을 최소화 시키는 것이 중요하다.
  - 익스플로러의 경우 GC가 너무 자주 실행되어 문제였다.

가비지 컬렉션의 대상
- 힙 영역에 있는 객체가 참조되고 있는 상태에 따라 Reachable / Unreachable 로 구분하여 Unreachable 상태인 객체는 GC 대상이 된다.
  - JVM 메모리 영역은 Stack, Method, Heap 영역으로 나눠지고, Heap 영역에 실제 객체가 생성되며 Stack과 Method 영역에서는 객체의 주소만 참조하여 사용하는데,
    method 가 끝나거나, 참조 변수가 삭제되는 등의 참조가 끊어지게 되면 Unreachable 상태가 되면서 GC의 대상이 된다.

가비지 컬렉션의 동작 과정
- 객체가 저장되는 Heap 영역은 크게 Young / Old Generation 영역으로 나뉜다.
  - 대부분의 객체는 Young 영역에 생성되었다가 금새 Unreachable 상태가 되어 사라지게 된다.
  - Young 영역은 다시 Eden / Survivor 0 / Survivor 1 으로 나눠지며, Eden 에서 살아남은 객체는 Survivor 0 과 1 을 오가며 저장된다.
    - 이때, 0과 1에 오가며 저장하는 이유는 단편화를 없애고 한곳에 모아 빠르게 읽기 위함이며 반드시 한 군데는 비어있어야 한다.
  - Survivor 영역에서 살아남은 객체는 Old 영역으로 이동된다.
    - Survivor 영역에서 살아남는 동안 객체들은 age 라는 값을 가지며 일반적으로 임계값 31에 도달하면 Old 영역으로 이동된다.
    - age 값은 Object Header에 기록되는데 저장공간이 6bit 라서 임계값을 31로 갖는다.
- Young 영역이 꽉 차서 부족하게 되면 Minor GC 가 발생하고, Old 영역이 부족하게 되면 Major GC 가 발생하게 된다.
  - Major GC (=Full GC) 는 Old 영역이 Young 영역에 비해 더 큰 만큼 실행 속도가 오래 걸리고 STW 가 발생하게 된다. 